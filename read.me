# ğŸ” DÃ©mo Flask XSS & Analyse SonarQube

## ğŸ“Œ Contexte
Ce projet met en place un pipeline qui dÃ©ploie une **application Flask volontairement vulnÃ©rable**, puis lâ€™analyse avec **SonarQube**.  
Objectif : illustrer la dÃ©tection automatique dâ€™une faille de type **Cross-Site Scripting (XSS)**.

---

## ğŸš¨ RÃ©sultat SonarQube

### Ce que Sonar a dÃ©tectÃ©
- **RÃ¨gle** : *â€œChange this code to not construct HTML content directly from user-controlled dataâ€*  
  (`pythonsecurity:S5496`)
- **GravitÃ©** : **Security / Blocker**  
- **VulnÃ©rabilitÃ©** : **XSS (Cross-Site Scripting)**
- **Pourquoi** : le code gÃ©nÃ¨re du HTML en concatÃ©nant une valeur **contrÃ´lÃ©e par lâ€™utilisateur** (`name`), et lâ€™envoie directement au navigateur.

---

## ğŸ” TraÃ§age source â†’ sink

Sonar montre le flux en 5 Ã©tapes :

1. **SOURCE** : lâ€™utilisateur peut injecter du contenu via HTTP (`request.args.get('name', 'visiteur')`).
2. La valeur est stockÃ©e dans la variable `name`.
3. La valeur est insÃ©rÃ©e dans une f-string Python.
4. La f-string devient du HTML grÃ¢ce Ã  `render_template_string`.
5. **SINK** : le navigateur reÃ§oit du HTML non Ã©chappÃ©.  
   â†’ Si `name` contient `<script>...</script>`, le JavaScript est exÃ©cutÃ©.

ğŸ‘‰ En clair : *Ne construisez pas du HTML avec des donnÃ©es brutes de lâ€™utilisateur !*

---

## âš ï¸ Exemple de code vulnÃ©rable

```python
name = request.args.get('name', 'visiteur')
return render_template_string(f"<h1>Bonjour {name}</h1>")
name provient directement de la requÃªte (non validÃ©, non Ã©chappÃ©).

f"...{name}..." injecte la valeur brute dans le HTML.

âœ… Solutions de correction
1) Utiliser un template Jinja (recommandÃ©)
Jinja2 applique lâ€™auto-escape par dÃ©faut.

python
Copier le code
from flask import Flask, render_template, request

@app.route("/")
def index():
    name = request.args.get("name", "visiteur")
    return render_template("index.html", name=name)
templates/index.html

html
Copier le code
<h1>Bonjour {{ name }}</h1>  <!-- auto-Ã©chappÃ© -->
2) Avec render_template_string (Ã©chappement explicite)
python
Copier le code
from flask import Flask, request, render_template_string

@app.route("/")
def index():
    name = request.args.get("name", "visiteur")
    return render_template_string("<h1>Bonjour {{ name|e }}</h1>", name=name)
3) Ã‰chapper cÃ´tÃ© Python (moins idiomatique Flask)
python
Copier le code
from markupsafe import escape

@app.route("/")
def index():
    name = escape(request.args.get("name", "visiteur"))
    return f"<h1>Bonjour {name}</h1>"
ğŸ’¡ Bonnes pratiques
Ne jamais dÃ©sactiver lâ€™auto-escape Jinja.

Toujours valider et normaliser les entrÃ©es (longueur, charset, liste blanche).

SÃ©parer logique et prÃ©sentation (Ã©viter f-strings HTML avec inputs).

IntÃ©grer SonarQube dans le pipeline CI/CD pour dÃ©tecter automatiquement ces vulnÃ©rabilitÃ©s.

Conclusion
Le pipeline a correctement rempli sa mission :

Il a gÃ©nÃ©rÃ© une app Flask vulnÃ©rable.

SonarQube a identifiÃ© une faille XSS (injection de contenu utilisateur non Ã©chappÃ©).

En appliquant lâ€™une des corrections ci-dessus, la rÃ¨gle Sonar sera respectÃ©e et la vulnÃ©rabilitÃ© supprimÃ©e.
