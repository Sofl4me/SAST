# 🔐 Démo Flask XSS & Analyse SonarQube

## 📌 Contexte
Ce projet met en place un pipeline qui déploie une **application Flask volontairement vulnérable**, puis l’analyse avec **SonarQube**.  
Objectif : illustrer la détection automatique d’une faille de type **Cross-Site Scripting (XSS)**.

---

## 🚨 Résultat SonarQube

### Ce que Sonar a détecté
- **Règle** : *“Change this code to not construct HTML content directly from user-controlled data”*  
  (`pythonsecurity:S5496`)
- **Gravité** : **Security / Blocker**  
- **Vulnérabilité** : **XSS (Cross-Site Scripting)**
- **Pourquoi** : le code génère du HTML en concaténant une valeur **contrôlée par l’utilisateur** (`name`), et l’envoie directement au navigateur.

---

## 🔎 Traçage source → sink

Sonar montre le flux en 5 étapes :

1. **SOURCE** : l’utilisateur peut injecter du contenu via HTTP (`request.args.get('name', 'visiteur')`).
2. La valeur est stockée dans la variable `name`.
3. La valeur est insérée dans une f-string Python.
4. La f-string devient du HTML grâce à `render_template_string`.
5. **SINK** : le navigateur reçoit du HTML non échappé.  
   → Si `name` contient `<script>...</script>`, le JavaScript est exécuté.

👉 En clair : *Ne construisez pas du HTML avec des données brutes de l’utilisateur !*

---

## ⚠️ Exemple de code vulnérable

```python
name = request.args.get('name', 'visiteur')
return render_template_string(f"<h1>Bonjour {name}</h1>")
name provient directement de la requête (non validé, non échappé).

f"...{name}..." injecte la valeur brute dans le HTML.

✅ Solutions de correction
1) Utiliser un template Jinja (recommandé)
Jinja2 applique l’auto-escape par défaut.

python
Copier le code
from flask import Flask, render_template, request

@app.route("/")
def index():
    name = request.args.get("name", "visiteur")
    return render_template("index.html", name=name)
templates/index.html

html
Copier le code
<h1>Bonjour {{ name }}</h1>  <!-- auto-échappé -->
2) Avec render_template_string (échappement explicite)
python
Copier le code
from flask import Flask, request, render_template_string

@app.route("/")
def index():
    name = request.args.get("name", "visiteur")
    return render_template_string("<h1>Bonjour {{ name|e }}</h1>", name=name)
3) Échapper côté Python (moins idiomatique Flask)
python
Copier le code
from markupsafe import escape

@app.route("/")
def index():
    name = escape(request.args.get("name", "visiteur"))
    return f"<h1>Bonjour {name}</h1>"
💡 Bonnes pratiques
Ne jamais désactiver l’auto-escape Jinja.

Toujours valider et normaliser les entrées (longueur, charset, liste blanche).

Séparer logique et présentation (éviter f-strings HTML avec inputs).

Intégrer SonarQube dans le pipeline CI/CD pour détecter automatiquement ces vulnérabilités.

Conclusion
Le pipeline a correctement rempli sa mission :

Il a généré une app Flask vulnérable.

SonarQube a identifié une faille XSS (injection de contenu utilisateur non échappé).

En appliquant l’une des corrections ci-dessus, la règle Sonar sera respectée et la vulnérabilité supprimée.
